{
  "name": "Tiny obj loader",
  "tagline": "Tiny but powerful single file wavefront obj loader",
  "body": "tinyobjloader\r\n=============\r\n\r\n[![Join the chat at https://gitter.im/syoyo/tinyobjloader](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/syoyo/tinyobjloader?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\n[![Build Status](https://travis-ci.org/syoyo/tinyobjloader.svg)](https://travis-ci.org/syoyo/tinyobjloader)\r\n\r\n[![wercker status](https://app.wercker.com/status/495a3bac400212cdacdeb4dd9397bf4f/m \"wercker status\")](https://app.wercker.com/project/bykey/495a3bac400212cdacdeb4dd9397bf4f)\r\n\r\n[![Build status](https://ci.appveyor.com/api/projects/status/tlb421q3t2oyobcn/branch/master?svg=true)](https://ci.appveyor.com/project/syoyo/tinyobjloader/branch/master)\r\n\r\n[![Coverage Status](https://coveralls.io/repos/github/syoyo/tinyobjloader/badge.svg?branch=master)](https://coveralls.io/github/syoyo/tinyobjloader?branch=master)\r\n\r\nhttp://syoyo.github.io/tinyobjloader/\r\n\r\nTiny but powerful single file wavefront obj loader written in C++. No dependency except for C++ STL. It can parse 10M over polygons with moderate memory and time.\r\n\r\n`tinyobjloader` is good for embedding .obj loader to your (global illumination) renderer ;-)\r\n\r\nNotice!\r\n-------\r\n\r\n`master` branch will be replaced with `develop` branch in the near future: https://github.com/syoyo/tinyobjloader/tree/develop\r\n`develop` branch has more better support and clean API interface for loading .obj and also it has optimized multi-threaded parser(probably 10x faster than `master`). If you are new to use `TinyObjLoader`, I highly recommend to use `develop` branch.\r\n\r\n\r\nWhat's new\r\n----------\r\n\r\n* Mar 13, 2016 : Introduce `load_flag_t` and flat normal calculation flag! Thanks Vazquinhos!\r\n* Jan 29, 2016 : Support n-polygon(no triangulation) and OpenSubdiv crease tag! Thanks dboogert!\r\n* Nov 26, 2015 : Now single-header only!.\r\n* Nov 08, 2015 : Improved API.\r\n* Jun 23, 2015 : Various fixes and added more projects using tinyobjloader. Thanks many contributors!\r\n* Mar 03, 2015 : Replace atof() with hand-written parser for robust reading of numeric value. Thanks skurmedel!\r\n* Feb 06, 2015 : Fix parsing multi-material object\r\n* Sep 14, 2014 : Add support for multi-material per object/group. Thanks Mykhailo!\r\n* Mar 17, 2014 : Fixed trim newline bugs. Thanks ardneran!\r\n* Apr 29, 2014 : Add API to read .obj from std::istream. Good for reading compressed .obj or connecting to procedural primitive generator. Thanks burnse!\r\n* Apr 21, 2014 : Define default material if no material definition exists in .obj. Thanks YarmUI!\r\n* Apr 10, 2014 : Add support for parsing 'illum' and 'd'/'Tr' statements. Thanks mmp!\r\n* Jan 27, 2014 : Added CMake project. Thanks bradc6!\r\n* Nov 26, 2013 : Performance optimization by NeuralSandwich. 9% improvement in his project, thanks!\r\n* Sep 12, 2013 : Added multiple .obj sticher example.\r\n\r\nExample\r\n-------\r\n\r\n![Rungholt](https://github.com/syoyo/tinyobjloader/blob/master/images/rungholt.jpg?raw=true)\r\n\r\ntinyobjloader can successfully load 6M triangles Rungholt scene.\r\nhttp://graphics.cs.williams.edu/data/meshes.xml\r\n\r\nUse case\r\n--------\r\n\r\nTinyObjLoader is successfully used in ...\r\n\r\n* bullet3 https://github.com/erwincoumans/bullet3\r\n* pbrt-v2 https://github.com/mmp/pbrt-v2\r\n* OpenGL game engine development http://swarminglogic.com/jotting/2013_10_gamedev01\r\n* mallie https://lighttransport.github.io/mallie\r\n* IBLBaker (Image Based Lighting Baker). http://www.derkreature.com/iblbaker/\r\n* Stanford CS148 http://web.stanford.edu/class/cs148/assignments/assignment3.pdf\r\n* Awesome Bump http://awesomebump.besaba.com/about/\r\n* sdlgl3-wavefront OpenGL .obj viewer https://github.com/chrisliebert/sdlgl3-wavefront\r\n* pbrt-v3 https://github.com/mmp/pbrt-v3\r\n* cocos2d-x https://github.com/cocos2d/cocos2d-x/\r\n* Android Vulkan demo https://github.com/SaschaWillems/Vulkan\r\n* voxelizer https://github.com/karimnaaji/voxelizer\r\n* Probulator https://github.com/kayru/Probulator\r\n* OptiX Prime baking https://github.com/nvpro-samples/optix_prime_baking\r\n* FireRays SDK https://github.com/GPUOpen-LibrariesAndSDKs/FireRays_SDK\r\n* parg, tiny C library of various graphics utilities and GL demos https://github.com/prideout/parg\r\n* Opengl unit of ChronoEngine https://github.com/projectchrono/chrono-opengl\r\n* Your project here!\r\n\r\nFeatures\r\n--------\r\n\r\n* Group(parse multiple group name)\r\n* Vertex\r\n* Texcoord\r\n* Normal\r\n* Material\r\n  * Unknown material attributes are returned as key-value(value is string) map.\r\n* Crease tag('t'). This is OpenSubdiv specific(not in wavefront .obj specification)\r\n\r\n\r\nTODO\r\n----\r\n\r\n* [ ] Support different indices for vertex/normal/texcoord\r\n\r\nLicense\r\n-------\r\n\r\nLicensed under 2 clause BSD.\r\n\r\nUsage\r\n-----\r\n\r\nTinyObjLoader triangulate input .obj by default.\r\n```c++\r\n#define TINYOBJLOADER_IMPLEMENTATION // define this in only *one* .cc\r\n#include \"tiny_obj_loader.h\"\r\n\r\nstd::string inputfile = \"cornell_box.obj\";\r\nstd::vector<tinyobj::shape_t> shapes;\r\nstd::vector<tinyobj::material_t> materials;\r\n  \r\nstd::string err;\r\nbool ret = tinyobj::LoadObj(shapes, materials, err, inputfile.c_str());\r\n  \r\nif (!err.empty()) { // `err` may contain warning message.\r\n  std::cerr << err << std::endl;\r\n}\r\n\r\nif (!ret) {\r\n  exit(1);\r\n}\r\n\r\nstd::cout << \"# of shapes    : \" << shapes.size() << std::endl;\r\nstd::cout << \"# of materials : \" << materials.size() << std::endl;\r\n  \r\nfor (size_t i = 0; i < shapes.size(); i++) {\r\n  printf(\"shape[%ld].name = %s\\n\", i, shapes[i].name.c_str());\r\n  printf(\"Size of shape[%ld].indices: %ld\\n\", i, shapes[i].mesh.indices.size());\r\n  printf(\"Size of shape[%ld].material_ids: %ld\\n\", i, shapes[i].mesh.material_ids.size());\r\n  assert((shapes[i].mesh.indices.size() % 3) == 0);\r\n  for (size_t f = 0; f < shapes[i].mesh.indices.size() / 3; f++) {\r\n    printf(\"  idx[%ld] = %d, %d, %d. mat_id = %d\\n\", f, shapes[i].mesh.indices[3*f+0], shapes[i].mesh.indices[3*f+1], shapes[i].mesh.indices[3*f+2], shapes[i].mesh.material_ids[f]);\r\n  }\r\n\r\n  printf(\"shape[%ld].vertices: %ld\\n\", i, shapes[i].mesh.positions.size());\r\n  assert((shapes[i].mesh.positions.size() % 3) == 0);\r\n  for (size_t v = 0; v < shapes[i].mesh.positions.size() / 3; v++) {\r\n    printf(\"  v[%ld] = (%f, %f, %f)\\n\", v,\r\n      shapes[i].mesh.positions[3*v+0],\r\n      shapes[i].mesh.positions[3*v+1],\r\n      shapes[i].mesh.positions[3*v+2]);\r\n  }\r\n}\r\n\r\nfor (size_t i = 0; i < materials.size(); i++) {\r\n  printf(\"material[%ld].name = %s\\n\", i, materials[i].name.c_str());\r\n  printf(\"  material.Ka = (%f, %f ,%f)\\n\", materials[i].ambient[0], materials[i].ambient[1], materials[i].ambient[2]);\r\n  printf(\"  material.Kd = (%f, %f ,%f)\\n\", materials[i].diffuse[0], materials[i].diffuse[1], materials[i].diffuse[2]);\r\n  printf(\"  material.Ks = (%f, %f ,%f)\\n\", materials[i].specular[0], materials[i].specular[1], materials[i].specular[2]);\r\n  printf(\"  material.Tr = (%f, %f ,%f)\\n\", materials[i].transmittance[0], materials[i].transmittance[1], materials[i].transmittance[2]);\r\n  printf(\"  material.Ke = (%f, %f ,%f)\\n\", materials[i].emission[0], materials[i].emission[1], materials[i].emission[2]);\r\n  printf(\"  material.Ns = %f\\n\", materials[i].shininess);\r\n  printf(\"  material.Ni = %f\\n\", materials[i].ior);\r\n  printf(\"  material.dissolve = %f\\n\", materials[i].dissolve);\r\n  printf(\"  material.illum = %d\\n\", materials[i].illum);\r\n  printf(\"  material.map_Ka = %s\\n\", materials[i].ambient_texname.c_str());\r\n  printf(\"  material.map_Kd = %s\\n\", materials[i].diffuse_texname.c_str());\r\n  printf(\"  material.map_Ks = %s\\n\", materials[i].specular_texname.c_str());\r\n  printf(\"  material.map_Ns = %s\\n\", materials[i].specular_highlight_texname.c_str());\r\n  std::map<std::string, std::string>::const_iterator it(materials[i].unknown_parameter.begin());\r\n  std::map<std::string, std::string>::const_iterator itEnd(materials[i].unknown_parameter.end());\r\n  for (; it != itEnd; it++) {\r\n    printf(\"  material.%s = %s\\n\", it->first.c_str(), it->second.c_str());\r\n  }\r\n  printf(\"\\n\");\r\n}\r\n```\r\n\r\nReading .obj without triangulation. Use `num_vertices[i]` to iterate over faces(indices). `num_vertices[i]` stores the number of vertices for ith face.\r\n```c++\r\n#define TINYOBJLOADER_IMPLEMENTATION // define this in only *one* .cc\r\n#include \"tiny_obj_loader.h\"\r\n\r\nstd::string inputfile = \"cornell_box.obj\";\r\nstd::vector<tinyobj::shape_t> shapes;\r\nstd::vector<tinyobj::material_t> materials;\r\n  \r\nstd::string err;\r\nint flags = 1; // see load_flags_t enum for more information.\r\nbool ret = tinyobj::LoadObj(shapes, materials, err, inputfile.c_str(), flags);\r\n  \r\nif (!err.empty()) { // `err` may contain warning message.\r\n  std::cerr << err << std::endl;\r\n}\r\n\r\nif (!ret) {\r\n  exit(1);\r\n}\r\n\r\nfor (size_t i = 0; i < shapes.size(); i++) {\r\n\r\n  size_t indexOffset = 0;\r\n  for (size_t n = 0; n < shapes[i].mesh.num_vertices.size(); n++) {\r\n    int ngon = shapes[i].mesh.num_vertices[n];\r\n    for (size_t f = 0; f < ngon; f++) {\r\n      unsigned int v = shapes[i].mesh.indices[indexOffset + f];\r\n      printf(\"  face[%ld] v[%ld] = (%f, %f, %f)\\n\", n,\r\n        shapes[i].mesh.positions[3*v+0],\r\n        shapes[i].mesh.positions[3*v+1],\r\n        shapes[i].mesh.positions[3*v+2]);\r\n      \r\n    }\r\n    indexOffset += ngon;\r\n  }\r\n\r\n}\r\n```\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}