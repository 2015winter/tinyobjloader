{"name":"Tiny obj loader","tagline":"Tiny but powerful single file wavefront obj loader","body":"tinyobjloader\r\n=============\r\n\r\nhttp://syoyo.github.io/tinyobjloader/\r\n\r\nTiny but poweful single file wavefront obj loader written in C++. No dependency except for C++ STL. It can parse 10M over polygons with moderate memory and time.\r\n\r\nGood for embedding .obj loader to your (global illumination) renderer ;-)\r\n\r\n\r\nExample\r\n-------\r\n\r\n![Rungholt](https://github.com/syoyo/tinyobjloader/blob/master/images/rungholt.jpg?raw=true)\r\n\r\ntinyobjloader can successfully load 6M triangles Rungholt scene.\r\nhttp://graphics.cs.williams.edu/data/meshes.xml\r\n\r\nFeatures\r\n--------\r\n\r\n* Group\r\n* Vertex\r\n* Texcoord\r\n* Normal\r\n* Material\r\n  * Unknown material attributes are treated as key-value.\r\n\r\nNotes\r\n-----\r\n\r\nPolygon is converted into triangle.\r\n\r\nLicense\r\n-------\r\n\r\nLicensed under 2 clause BSD.\r\n\r\nUsage\r\n-----\r\n\r\n    std::string inputfile = \"cornell_box.obj\";\r\n    std::vector<tinyobj::shape_t> shapes;\r\n  \r\n    std::string err = tinyobj::LoadObj(shapes, inputfile.c_str());\r\n  \r\n    if (!err.empty()) {\r\n      std::cerr << err << std::endl;\r\n      exit(1);\r\n    }\r\n  \r\n    std::cout << \"# of shapes : \" << shapes.size() << std::endl;\r\n  \r\n    for (size_t i = 0; i < shapes.size(); i++) {\r\n      printf(\"shape[%ld].name = %s\\n\", i, shapes[i].name.c_str());\r\n      printf(\"shape[%ld].indices: %ld\\n\", i, shapes[i].mesh.indices.size());\r\n      assert((shapes[i].mesh.indices.size() % 3) == 0);\r\n      for (size_t f = 0; f < shapes[i].mesh.indices.size(); f++) {\r\n        printf(\"  idx[%ld] = %d\\n\", f, shapes[i].mesh.indices[f]);\r\n      }\r\n  \r\n      printf(\"shape[%ld].vertices: %ld\\n\", i, shapes[i].mesh.positions.size());\r\n      assert((shapes[i].mesh.positions.size() % 3) == 0);\r\n      for (size_t v = 0; v < shapes[i].mesh.positions.size() / 3; v++) {\r\n        printf(\"  v[%ld] = (%f, %f, %f)\\n\", v,\r\n          shapes[i].mesh.positions[3*v+0],\r\n          shapes[i].mesh.positions[3*v+1],\r\n          shapes[i].mesh.positions[3*v+2]);\r\n      }\r\n    \r\n      printf(\"shape[%ld].material.name = %s\\n\", i, shapes[i].material.name.c_str());\r\n      printf(\"  material.Ka = (%f, %f ,%f)\\n\", shapes[i].material.ambient[0], shapes[i].material.ambient[1], shapes[i].material.ambient[2]);\r\n      printf(\"  material.Kd = (%f, %f ,%f)\\n\", shapes[i].material.diffuse[0], shapes[i].material.diffuse[1], shapes[i].material.diffuse[2]);\r\n      printf(\"  material.Ks = (%f, %f ,%f)\\n\", shapes[i].material.specular[0], shapes[i].material.specular[1], shapes[i].material.specular[2]);\r\n      printf(\"  material.Tr = (%f, %f ,%f)\\n\", shapes[i].material.transmittance[0], shapes[i].material.transmittance[1], shapes[i].material.transmittance[2]);\r\n      printf(\"  material.Ke = (%f, %f ,%f)\\n\", shapes[i].material.emission[0], shapes[i].material.emission[1], shapes[i].material.emission[2]);\r\n      printf(\"  material.Ns = %f\\n\", shapes[i].material.shininess);\r\n      printf(\"  material.map_Ka = %s\\n\", shapes[i].material.ambient_texname.c_str());\r\n      printf(\"  material.map_Kd = %s\\n\", shapes[i].material.diffuse_texname.c_str());\r\n      printf(\"  material.map_Ks = %s\\n\", shapes[i].material.specular_texname.c_str());\r\n      printf(\"  material.map_Ns = %s\\n\", shapes[i].material.normal_texname.c_str());\r\n      std::map<std::string, std::string>::iterator it(shapes[i].material.unknown_parameter.begin());\r\n      std::map<std::string, std::string>::iterator itEnd(shapes[i].material.unknown_parameter.end());\r\n      for (; it != itEnd; it++) {\r\n        printf(\"  material.%s = %s\\n\", it->first.c_str(), it->second.c_str());\r\n      }\r\n      printf(\"\\n\");\r\n    }\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}